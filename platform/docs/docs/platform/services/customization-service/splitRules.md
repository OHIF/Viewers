---
sidebar_label: Split Rules
sidebar_position: 5
title: SOP Class Handler Split Rules Customization
summary: Documentation for customizing how DICOM series are split into display sets using split rules, allowing fine-grained control over series grouping and organization.
---

# SOP Class Handler Split Rules

SOP Class Handler Split Rules control how DICOM series are divided into separate display sets in OHIF. When a series is loaded, the split rules determine which instances should be grouped together and which should be separated into distinct display sets.

## Overview

The split rules system is used by the SOP Class Handler module to process instances from a DICOM series and organize them into display sets. Each split rule defines:

- **When it applies**: Which instances match this rule (`ruleSelector`)
- **How to group**: What key is used to group instances (`splitKey`)
- **What attributes to set**: Custom attributes for display sets created by this rule (`customAttributes`)
- **Series-level information**: Optional series metadata preparation (`makeSeriesInfo`)

The split rules are retrieved from the customization service using the key `'splitRules.default'` as configured in `getSopClassHandlerModule.js`.

## How Split Rules Work

The split rules processing flow (as implemented in `utils/getDisplaySetsFromSeries.ts`) works as follows:

1. **Series Information Gathering**: Each rule's `makeSeriesInfo` function (if provided) is called to populate series-level metadata that can be used by rule selectors.

2. **Rule Matching**: For each instance in the series, rules are evaluated in order. The first matching rule (where `ruleSelector` returns `true`) determines how the instance is categorized.

3. **Grouping**: Instances are grouped based on the `splitKey` value generated by the matching rule. Instances with the same split key are placed in the same display set.

4. **Display Set Creation**: Each group of instances creates a separate display set with attributes determined by:
   - Default display set attributes
   - Series information
   - Rule-specific custom attributes (from `customAttributes` function)

## Split Rule Structure

Each split rule is an object with the following properties:

### Required Properties

- **`id`** (string): A unique identifier for the rule, useful for debugging

- **`ruleSelector`** (function): A function that determines if an instance matches this rule
  ```typescript
  ruleSelector: (instance: InstanceMetadata, seriesInfo: SeriesInfo) => boolean
  ```
  - Returns `true` if the instance matches this rule
  - The first matching rule is used (rules are evaluated in order)
  - If `ruleSelector` is not provided, the rule will match all instances

### Optional Properties

- **`splitKey`** (array): Determines how instances are grouped into display sets
  ```typescript
  splitKey: (string | function)[]
  ```
  - Can be an array of strings (DICOM tag names) or functions
  - Functions receive `(instance, seriesInfo)` and return a value
  - Values are joined with `&` to create a unique key for grouping
  - Default: `['SeriesInstanceUID']` (all instances in same series go to same display set)

- **`makeSeriesInfo`** (function): Modifies series-level information before rule evaluation
  ```typescript
  makeSeriesInfo: (instances: InstanceMetadata[], seriesInfo: SeriesInfo) => SeriesInfo | void
  ```
  - Called once per series before rule evaluation
  - Can add custom properties to `seriesInfo` that rule selectors can use
  - Return the modified `seriesInfo` or nothing (modification by reference)

- **`customAttributes`** (function): Adds custom attributes to display sets created by this rule
  ```typescript
  customAttributes: (attributes: object, options: { instances, splitNumber }) => object
  ```
  - Called for each display set created by this rule
  - Receives default attributes and options
  - Returns an object with additional attributes to merge into the display set

## Default Split Rules

The default split rules are defined in `extensions/default/src/customizations/defaultSplitRulesCustomization.ts`. They include:

### 1. Single Image Modality Rule

Splits single-image modalities (CR, DX, MG) into separate display sets based on image dimensions.

```typescript
{
  id: 'singleImageModality',
  ruleSelector: instance =>
    ['CR', 'DX', 'MG'].includes(instance.Modality) &&
    isImage(instance.SOPClassUID) &&
    instance.Rows,
  splitKey: [
    instance =>
      `rows=${Math.round(instance.Rows / 64)}&cols=${Math.round(instance.Columns / 64)}`,
  ],
}
```

**Behavior**: Instances with the same approximate dimensions (rounded to 64-pixel buckets) are grouped together.

### 2. Multi-Frame Rule

Handles multi-frame instances (instances with `NumberOfFrames > 1`).

```typescript
{
  id: 'multiFrame',
  makeSeriesInfo: (instances, seriesInfo) => {
    const { NumberOfFrames, SliceLocation } = instances[0];
    seriesInfo.isMultiFrame = NumberOfFrames > 1 && SliceLocation;
    return seriesInfo;
  },
  customAttributes: function ({ instance, isMultiFrame }, options) {
    return {
      isClip: true,
      numImageFrames: instance.NumberOfFrames,
      splitNumber: options?.splitNumber,
      descriptionName: options?.descriptionName,
      isMultiFrame,
    };
  },
  ruleSelector: (_instance, seriesInfo) => seriesInfo.isMultiFrame,
  splitKey: ['SeriesInstanceUID', 'InstanceNumber'],
}
```

**Behavior**:
- Detects multi-frame instances with slice location
- Splits each multi-frame instance into its own display set
- Adds special attributes like `isClip: true` and frame count

### 3. Mixed Dimensionality B-Value Rule

Handles MR series with mixed B-value instances (some with B-values, some without).

```typescript
{
  id: 'mixedDimensionalityBValue',
  makeSeriesInfo: (instances, seriesInfo) => {
    const [instance] = instances;
    const { Modality } = instance;
    if (Modality !== 'MR') {
      return;
    }
    const hasBValue = instances.some(i => i.DiffusionBValue !== undefined);
    if (!hasBValue) {
      return;
    }
    const missingBValue = instances.some(i => i.DiffusionBValue === undefined);
    if (!missingBValue) {
      return;
    }
    seriesInfo.mixedBValue = true;
    return seriesInfo;
  },
  ruleSelector: (_instance, seriesInfo) => {
    return seriesInfo.mixedBValue;
  },
  splitKey: ['SeriesInstanceUID', (instance) => instance.DiffusionBValue === undefined],
}
```

**Behavior**: Separates instances with B-values from those without, creating separate display sets for diffusion-weighted and non-diffusion images.

### 4. Default Image Rule

Catch-all rule for all other image instances.

```typescript
{
  id: 'defaultImageRule',
  ruleSelector: instance => isImage(instance.SOPClassUID) && instance.Rows,
}
```

**Behavior**: Matches any image instance that hasn't been matched by previous rules. All such instances are grouped together in a single display set.

## Customizing Split Rules

### Method 1: Override Individual Rules

You can override specific rules while keeping the default set:

```typescript
import { customizationService } from '@ohif/core';

customizationService.setCustomizations({
  'splitRules.default': {
    $modify: [
      {
        id: 'singleImageModality',
        ruleSelector: instance =>
          ['CR', 'DX', 'MG'].includes(instance.Modality) &&
          isImage(instance.SOPClassUID) &&
          instance.Rows,
        splitKey: ['SeriesInstanceUID'], // Changed: group all single images together
      },
    ],
  },
});
```

### Method 2: Replace All Rules

Replace the entire rules array:

```typescript
customizationService.setCustomizations({
  'splitRules.default': {
    $set: [
      {
        id: 'myCustomRule',
        ruleSelector: instance => instance.Modality === 'CT',
        splitKey: ['SeriesInstanceUID', 'SeriesNumber'],
      },
      {
        id: 'defaultImageRule',
        ruleSelector: instance => isImage(instance.SOPClassUID) && instance.Rows,
      },
    ],
  },
});
```

### Method 3: Add New Rules

Add additional rules to the default set:

```typescript
customizationService.setCustomizations({
  'splitRules.default': {
    $insertAfter: [
      {
        id: 'myNewRule',
        ruleSelector: instance => instance.Modality === 'US',
        splitKey: ['SeriesInstanceUID', 'AcquisitionDateTime'],
        customAttributes: ({ instance }, options) => ({
          isUltrasound: true,
          acquisitionTime: instance.AcquisitionDateTime,
        }),
      },
    ],
    matchId: 'multiFrame', // Insert after the multiFrame rule
  },
});
```

## Custom Rule Examples

### Example 1: Split by Echo Time

Split MR images by echo time:

```typescript
{
  id: 'splitByEchoTime',
  ruleSelector: instance => instance.Modality === 'MR' && instance.EchoTime,
  splitKey: ['SeriesInstanceUID', 'EchoTime'],
  customAttributes: ({ instance }) => ({
    echoTime: instance.EchoTime,
  }),
}
```

### Example 2: Split by Contrast Agent

Separate contrast-enhanced from non-contrast images:

```typescript
{
  id: 'splitByContrast',
  ruleSelector: instance =>
    ['CT', 'MR'].includes(instance.Modality) &&
    instance.ContrastBolusAgent,
  splitKey: [
    'SeriesInstanceUID',
    instance => instance.ContrastBolusAgent ? 'with-contrast' : 'without-contrast'
  ],
  customAttributes: ({ instance }) => ({
    hasContrast: !!instance.ContrastBolusAgent,
    contrastAgent: instance.ContrastBolusAgent || 'None',
  }),
}
```

### Example 3: Series-Level Detection with Custom Split Key

Use series information to determine split behavior:

```typescript
{
  id: 'splitByPhase',
  makeSeriesInfo: (instances, seriesInfo) => {
    // Check if series has multiple cardiac phases
    const phases = new Set(
      instances
        .map(i => i.CardiacCyclePosition)
        .filter(p => p !== undefined)
    );
    if (phases.size > 1) {
      seriesInfo.hasMultiplePhases = true;
    }
    return seriesInfo;
  },
  ruleSelector: (_instance, seriesInfo) => seriesInfo.hasMultiplePhases,
  splitKey: ['SeriesInstanceUID', 'CardiacCyclePosition'],
  customAttributes: ({ instance }) => ({
    cardiacPhase: instance.CardiacCyclePosition,
  }),
}
```

## Best Practices

1. **Rule Order Matters**: Rules are evaluated in order, and the first matching rule is used. Place more specific rules before general ones.

2. **Use `makeSeriesInfo` for Expensive Checks**: If you need to check all instances in a series, do it in `makeSeriesInfo` and cache the result in `seriesInfo` rather than checking in `ruleSelector`.

3. **Split Keys Should Be Unique**: Ensure your `splitKey` generates unique values for instances that should be in different display sets.

4. **Provide Meaningful IDs**: Use descriptive `id` values to help with debugging when viewing console logs.

5. **Test with Various Data**: Test your custom rules with different types of DICOM series to ensure they work as expected.

## Related Files

- **Default rules**: `extensions/default/src/customizations/defaultSplitRulesCustomization.ts`
- **Implementation**: `extensions/default/src/utils/getDisplaySetsFromSeries.ts`
- **SOP Class Handler**: `extensions/default/src/getSopClassHandlerModule.js`
