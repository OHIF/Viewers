const pluginConfig = require('../pluginConfig.json');
const fs = require('fs');

const autogenerationDisclaimer = `
// THIS FILE IS AUTOGENERATED AS PART OF THE EXTENSION AND MODE PLUGIN PROCESS.
// IT SHOULD NOT BE MODIFIED MANUALLY \n`;

function constructLines(input, categoryName) {
  let pluginCount = 0;

  const lines = {
    importLines: [],
    addToWindowLines: [],
  };

  if (!input) return lines;

  input.forEach((entry) => {
    const packageName = entry.packageName;

    const defaultImportName = `${categoryName}${pluginCount}`;

    lines.importLines.push(
      `import ${defaultImportName} from '${packageName}';\n`
    );
    lines.addToWindowLines.push(
      `${categoryName}.push(${defaultImportName});\n`
    );

    pluginCount++;
  });

  return lines;
}

function getFormattedImportBlock(importLines) {
  let content = '';
  // Imports
  importLines.forEach((importLine) => {
    content += importLine;
  });

  return content;
}

function getFormattedWindowBlock(addToWindowLines) {
  let content =
    'const extensions = [];\n' +
    'const modes = [];\n' +
    'const modesFactory = [];\n' +
    'window.extensions = extensions;\n' +
    'window.modes = modes;\n\n';

  addToWindowLines.forEach((addToWindowLine) => {
    content += addToWindowLine;
  });

  return content;
}

function getRuntimeLoadModesExtensions() {
  return (
    '\n\n// Add a dynamic runtime loader\n' +
    'export default async () => {\n' +
    ' for(const modeFactory of modesFactory) {\n' +
    '  const newModes = await modeFactory(modes,extensions);\n' +
    '  newModes.forEach(newMode => modes.push(newMode));\n' +
    '}\n}\n'
  );
}

const createCopyPluginPublicToDist = (SRC_DIR, DIST_DIR, plugins) => {
  return plugins
    .map((plugin) => {
      const from = `${SRC_DIR}/../../../node_modules/${plugin.packageName}/public/`;
      const exists = fs.existsSync(from);
      return exists
        ? {
            from,
            to: DIST_DIR,
            toType: 'dir',
          }
        : undefined;
    })
    .filter((x) => !!x);
};

const createCopyPluginDistToDist = (SRC_DIR, DIST_DIR, plugins) => {
  return plugins
    .map((plugin) => {
      const from = `${SRC_DIR}/../../../node_modules/${plugin.packageName}/dist/`;
      const exists = fs.existsSync(from);
      return exists
        ? {
            from,
            to: DIST_DIR,
            toType: 'dir',
          }
        : undefined;
    })
    .filter((x) => !!x);
};

function writePluginImportsFile(SRC_DIR, DIST_DIR) {
  let pluginImportsJsContent = autogenerationDisclaimer;

  const extensionLines = constructLines(pluginConfig.extensions, 'extensions');
  const modeLines = constructLines(pluginConfig.modes, 'modes');
  const modesFactoryLines = constructLines(
    pluginConfig.modesFactory,
    'modesFactory'
  );

  pluginImportsJsContent += getFormattedImportBlock([
    ...extensionLines.importLines,
    ...modeLines.importLines,
    ...modesFactoryLines.importLines,
  ]);
  pluginImportsJsContent += getFormattedWindowBlock([
    ...extensionLines.addToWindowLines,
    ...modeLines.addToWindowLines,
    ...modesFactoryLines.addToWindowLines,
  ]);

  pluginImportsJsContent += getRuntimeLoadModesExtensions();

  fs.writeFileSync(
    `${SRC_DIR}/pluginImports.js`,
    pluginImportsJsContent,
    { flag: 'w+' },
    (err) => {
      if (err) {
        console.error(err);
        return;
      }
    }
  );

  const copyPluginPublicToDist = createCopyPluginPublicToDist(
    SRC_DIR,
    DIST_DIR,
    [
      ...pluginConfig.modesFactory,
      ...pluginConfig.modes,
      ...pluginConfig.extensions,
      ...pluginConfig.umd,
    ]
  );
  const copyPluginDistToDist = createCopyPluginDistToDist(SRC_DIR, DIST_DIR, [
    ...pluginConfig.modesFactory,
    ...pluginConfig.modes,
    ...pluginConfig.extensions,
    ...pluginConfig.umd,
  ]);

  return [...copyPluginPublicToDist, ...copyPluginDistToDist];
}

module.exports = writePluginImportsFile;
