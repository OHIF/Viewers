{"version":3,"file":"workbox-streams.dev.js","sources":["../_version.js","../concatenate.js","../utils/createHeaders.js","../concatenateToResponse.js","../isSupported.js","../strategy.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:streams:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {module:workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n    if (source instanceof Response) {\n        return source.body.getReader();\n    }\n    if (source instanceof ReadableStream) {\n        return source.getReader();\n    }\n    return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenate(sourcePromises) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(sourcePromises, {\n            moduleName: 'workbox-streams',\n            funcName: 'concatenate',\n            paramName: 'sourcePromises',\n        });\n    }\n    const readerPromises = sourcePromises.map((sourcePromise) => {\n        return Promise.resolve(sourcePromise).then((source) => {\n            return _getReaderFromSource(source);\n        });\n    });\n    const streamDeferred = new Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n        pull(controller) {\n            return readerPromises[i]\n                .then((reader) => reader.read())\n                .then((result) => {\n                if (result.done) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logMessages.push(['Reached the end of source:',\n                            sourcePromises[i]]);\n                    }\n                    i++;\n                    if (i >= readerPromises.length) {\n                        // Log all the messages in the group at once in a single group.\n                        if (process.env.NODE_ENV !== 'production') {\n                            logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                            for (const message of logMessages) {\n                                if (Array.isArray(message)) {\n                                    logger.log(...message);\n                                }\n                                else {\n                                    logger.log(message);\n                                }\n                            }\n                            logger.log('Finished reading all sources.');\n                            logger.groupEnd();\n                        }\n                        controller.close();\n                        streamDeferred.resolve();\n                        return;\n                    }\n                    // The `pull` method is defined because we're inside it.\n                    return this.pull(controller);\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            }).catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error('An error occurred:', error);\n                }\n                streamDeferred.reject(error);\n                throw error;\n            });\n        },\n        cancel() {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn('The ReadableStream was cancelled.');\n            }\n            streamDeferred.resolve();\n        },\n    });\n    return { done: streamDeferred.promise, stream };\n}\nexport { concatenate };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @private\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n    if (!headers.has('content-type')) {\n        headers.set('content-type', 'text/html');\n    }\n    return headers;\n}\nexport { createHeaders };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenate } from './concatenate.js';\nimport './_version.js';\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n    const { done, stream } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, { headers });\n    return { done, response };\n}\nexport { concatenateToResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructReadableStream } from 'workbox-core/_private/canConstructReadableStream.js';\nimport './_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction isSupported() {\n    return canConstructReadableStream();\n}\nexport { isSupported };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {module:workbox-routing~handlerCallback}\n * @memberof module:workbox-streams\n */\nfunction strategy(sourceFunctions, headersInit) {\n    return async ({ event, request, url, params }) => {\n        const sourcePromises = sourceFunctions.map((fn) => {\n            // Ensure the return value of the function is always a promise.\n            return Promise.resolve(fn({ event, request, url, params }));\n        });\n        if (isSupported()) {\n            const { done, response } = concatenateToResponse(sourcePromises, headersInit);\n            if (event) {\n                event.waitUntil(done);\n            }\n            return response;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(`The current browser doesn't support creating response ` +\n                `streams. Falling back to non-streaming response instead.`);\n        }\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {\n            const source = await sourcePromise;\n            if (source instanceof Response) {\n                return source.blob();\n            }\n            else {\n                // Technically, a `StreamSource` object can include any valid\n                // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n                // cannot be passed to the Blob constructor directly, so we have to\n                // convert them to actual Blobs first.\n                return new Response(source).blob();\n            }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(blobParts), { headers });\n    };\n}\nexport { strategy };\n"],"names":["self","_","e","_getReaderFromSource","source","Response","body","getReader","ReadableStream","concatenate","sourcePromises","assert","isArray","moduleName","funcName","paramName","readerPromises","map","sourcePromise","Promise","resolve","then","streamDeferred","Deferred","i","logMessages","stream","pull","controller","reader","read","result","done","push","length","logger","groupCollapsed","message","Array","log","groupEnd","close","enqueue","value","catch","error","reject","cancel","warn","promise","createHeaders","headersInit","headers","Headers","has","set","concatenateToResponse","response","isSupported","canConstructReadableStream","strategy","sourceFunctions","event","request","url","params","fn","waitUntil","blobPartsPromises","blob","blobParts","all","Blob"],"mappings":"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"}